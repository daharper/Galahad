{-----------------------------------------------------------------------------------------------------------------------
  Project:     Escape
  Unit:        Base.Data
  Author:      David Harper
  License:     MIT
  History:     2026-08-02 Initial version 0.1
  Purpose:     Provides simple data abstractions for the minimal database requirements of Escape.
-----------------------------------------------------------------------------------------------------------------------}

unit Base.Data;

interface

uses
  System.SysUtils,
  System.Classes,
  System.Rtti,
  System.TypInfo,
  System.Variants,
  System.Generics.Collections,
  FireDAC.Comp.Client,
  FireDAC.Stan.Param,
  Base.Core,
  Base.Integrity,
  Base.Dynamic,
  Base.Specifications,
  Base.Stream;

type
  /// <summary>
  ///  Apply to non-persisted entity fields.
  /// </summary>
  TransientAttribute = class(TCustomAttribute) end;

  /// <summary>
  ///  Base interface for all entities.
  /// </summary>
  IEntity = interface
    ['{DFEF00C0-5695-443E-91A7-E79E794ED794}']

    /// <summary>Sets the Id.</summary>
    procedure SetId(const aId: integer);

    /// <summary>Gets the Id.</summary>
    function GetId: integer;

    /// <summary>Returns true if the entity does not have an Id.</summary>
    function IsNew: boolean;

    /// <summary>Returns true if the entity does have an Id.</summary>
    function Exists: boolean;

    property Id: integer read GetId write SetId;
  end;

  /// <summary>
  ///  This is the base entity class all domain entities in Escape use.
  ///
  ///  The following conventions are enforced:
  ///   - Decorate transient properties with [Transient]
  ///   - The name of the database table matches the name of the entity (TCustomer => Customer)
  ///   - The name of the database columns match the names of the properties
  ///   - Every table has an autogenerated Id field
  /// </summary>
  TEntity = class(TTransient, IEntity)
  private
    fId: integer;
  public
    procedure SetId(const aId: integer);

    function GetId: integer;
    function IsNew: boolean;
    function Exists: boolean;
  end;

  /// <summary>
  ///  An interface for essential database functionality.
  /// </summary>
  IDatabaseService = interface
    ['{957F3224-AE99-4870-A2B9-11B11881FDE3}']

    function Connection: TFDConnection;
    function Query: TFDQuery;
  end;

  /// <summary>
  ///  Set directives to affect the queries, before the query is executed.
  ///  Directives are cleared after each request.
  /// </summary>
  TDirective = (
    /// <summary>Limit the number of records returned</summary>
    tdLimit,
    /// <summary>Order ascending.</summary>
    tdAscending,
    /// <summary>Order descending.</summary>
    tdDescending,
    /// <summary>Begin at record offset.</summary>
    tdOffset
  );

  /// <summary>
  ///  Base interface for the repositories.
  /// </summary>
  IRepository<TService: IEntity; T: TEntity, constructor> = interface
    ['{2B0A8B8E-2A59-43E7-8B3F-0A6B8A2A4A3C}']

    function TableName: string;

//    function FirstBy(const aSpec: TSpecification<T>): TMaybe<T>;
    function GetAll: TArray<TService>;
    function GetBy(const aId: integer): TMaybe<TService>;
  end;

  /// <summary>
  ///  Base type for all repositories. Requires entities to follow the T[Table] naming convention,
  ///  for example, TCustomer for a table named Customer.
  /// </summary>
  TRepository<TService: IEntity; T: TEntity, constructor> = class(TDynamicObject, IRepository<TService, T>)
  private
    fDatabase: IDatabaseService;

    // data moves around internally in a list (efficient) but returns to the client as an Array (memory safe)
    fResults: TList<TService>;

    function GetQueryResults:TList<TService>;
  protected
    fDirectives: TDictionary<TDirective, string>;

    function Database: IDatabaseService;
    function Connection: TFDConnection;
    function Query: TFDQuery;

    function ExecQuery(const aSql: string):TList<TService>; overload;
    function ExecQuery:TList<TService>; overload;

    class var fName: string;
    class var fPropertyOrder: TList<string>;
    class var fProperties: TDictionary<string, TRttiProperty>;

    constructor Create(aDatabase: IDatabaseService);
  public
    function TableName: string;

    function GetAll: TArray<TService>;
    function GetBy(const aId: integer): TMaybe<TService>;

    destructor Destroy; override;

    class constructor Create;
    class destructor Destroy;
  end;

implementation

uses
  System.Generics.Defaults,
  Base.Reflection;

{ TEntity }

{----------------------------------------------------------------------------------------------------------------------}
function TEntity.GetId: integer;
begin
  Result := fId;
end;

{----------------------------------------------------------------------------------------------------------------------}
procedure TEntity.SetId(const aId: integer);
begin
  fId := aId;
end;

{----------------------------------------------------------------------------------------------------------------------}
function TEntity.Exists: boolean;
begin
  Result := fId > 0;
end;

{----------------------------------------------------------------------------------------------------------------------}
function TEntity.IsNew: boolean;
begin
  Result := fId < 1;
end;

{ TRepository<TService, T> }

{----------------------------------------------------------------------------------------------------------------------}
function TRepository<TService, T>.Database: IDatabaseService;
begin
  Result := fDatabase;
end;

{----------------------------------------------------------------------------------------------------------------------}
function TRepository<TService, T>.Connection: TFDConnection;
begin
  Result := fDatabase.Connection;
end;

{----------------------------------------------------------------------------------------------------------------------}
function TRepository<TService, T>.Query: TFDQuery;
begin
  Result := fDatabase.Query;
end;

{----------------------------------------------------------------------------------------------------------------------}
function TRepository<TService, T>.GetAll: TArray<TService>;
const
  SQL = 'select * from %s';
begin
  var qry := SQL.Format(SQL, [TableName]);
  Result := ExecQuery(qry).ToArray;
end;

{----------------------------------------------------------------------------------------------------------------------}
function TRepository<TService, T>.GetBy(const aId: integer): TMaybe<TService>;
const
  SQL = 'select * from %s where id = :id';
var
  lInstance: TService;
begin
  Query.SQL.Text := SQL.Format(SQL, [TableName, aId]);
  Query.ParamByName('id').AsInteger := aId;

  var list := ExecQuery;

  if list.IsEmpty then
    Result.SetNone
  else
  begin
    lInstance := list[0];
    Result.SetSome(lInstance);
  end;
end;

{----------------------------------------------------------------------------------------------------------------------}
function TRepository<TService, T>.TableName: string;
begin
  Result := fName;
end;

{----------------------------------------------------------------------------------------------------------------------}
function TRepository<TService, T>.ExecQuery(const aSql: string):TList<TService>;
begin
  Query.SQL.Text := aSQL;
  Result := ExecQuery;
end;

{----------------------------------------------------------------------------------------------------------------------}
function TRepository<TService, T>.ExecQuery: TList<TService>;
begin
  Query.Open;

  try
    Result := GetQueryResults;
  finally
    Query.Close;
  end;
end;

{----------------------------------------------------------------------------------------------------------------------}
function TRepository<TService, T>.GetQueryResults: TList<TService>;
const
  ERR = '%s does not support requested interface %s';
var
  lValue: TValue;
  lEntity: T;
  lName: string;
  lVariant: Variant;
  lProperty: TRttiProperty;
  lNamedProperty: TPair<string, TRttiProperty>;
begin
  fResults.Clear;

  Result := fResults;

  if Query.RecordCount = 0 then exit;

  Query.First;

  while not Query.Eof do
  begin
    lEntity := T.Create;

    for lNamedProperty in fProperties do
    begin
      lName     := lNamedProperty.Key;
      lProperty := lNamedProperty.Value;
      lVariant  := query[lName];

      if not TReflection.TryVariantToTValue(lVariant, lProperty.PropertyType.Handle, lValue) then
        lValue := TValue.FromVariant(lVariant);

      lProperty.SetValue(TObject(lEntity), lValue);
    end;

    Result.Add(TReflection.As<TService>(lEntity));

    Query.Next;
  end;
end;

{----------------------------------------------------------------------------------------------------------------------}
constructor TRepository<TService, T>.Create(aDatabase: IDatabaseService);
begin
  inherited Create;

  fDatabase   := aDatabase;
  fResults    := TList<TService>.Create;
  fDirectives := TDictionary<TDirective, string>.Create;
end;

{----------------------------------------------------------------------------------------------------------------------}
destructor TRepository<TService, T>.Destroy;
begin
  if Assigned(fResults) then
  begin
    fResults.Clear;
    fResults.Free;
  end;

  fDirectives.Free;

  inherited;
end;

{----------------------------------------------------------------------------------------------------------------------}
class constructor TRepository<TService, T>.Create;
const
  NAME_ERR = 'Entities should follow the T[Table] naming convention: %s';
  TYPE_ERR = '%s does not implement %s';
var
  lCtx: TRttiContext;
begin
  lCtx := TRttiContext.Create;

{$IFDEF DEBUG}
  // Delphi can't constrain Class + Interface on T, so we fail fast here.
  // T must implement TService.
  Assert(TReflection.Is<T, TService>, Format(TYPE_ERR, [T.ClassName, TReflection.TypeNameOf<TService>]));
{$ENDIF}

  var lType :=  lCtx.GetType(T);
  var lClass := TRttiInstanceType(lType);

{$IFDEF DEBUG}
  // Name entities with the T prefix convention so we know where to begin looking for the table name
  // The entity name should match T[Table], i.e. TCustomer => Customer
  Assert(lClass.Name.StartsWith('T', true), Format(NAME_ERR, [lClass.Name]));
{$ENDIF}

  fName := lClass.Name;
  fName := fName.Substring(1);

  fPropertyOrder := TList<string>.Create;
  fProperties := TDictionary<string, TRttiProperty>.Create(TIStringComparer.Ordinal);

  for var lProperty in lType.GetProperties do
  begin
    if SameText(lProperty.Name, 'RefCount') then Continue;

    if Assigned(lProperty.GetAttribute<TransientAttribute>()) then continue;

    fProperties.Add(lProperty.Name, lProperty);
    fPropertyOrder.Add(lProperty.Name);
  end;
end;

{----------------------------------------------------------------------------------------------------------------------}
class destructor TRepository<TService, T>.Destroy;
begin
  FreeAndNil(fProperties);
  FreeAndNil(fPropertyOrder);
end;

end.
