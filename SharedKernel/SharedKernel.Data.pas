{-----------------------------------------------------------------------------------------------------------------------
  Project:     Escape
  Unit:        SharedKernel.Data
  Author:      David Harper
  License:     MIT
  History:     2026-08-02 Initial version 0.1
  Purpose:     Provides simple data abstractions for the minimal database requirements of Escape.
-----------------------------------------------------------------------------------------------------------------------}

unit SharedKernel.Data;

interface

uses
  System.SysUtils,
  System.Classes,
  System.Rtti,
  System.TypInfo,
  System.Variants,
  System.Generics.Collections,
  FireDAC.Comp.Client,
  Base.Core,
  Base.Integrity,
  Base.Dynamic,
  Base.Specifications,
  Base.Stream;

type
  /// <summary>
  ///  Apply to non-persisted entity fields.
  /// </summary>
  TransientAttribute = class(TCustomAttribute) end;

  /// <summary>
  ///  Base interface for all entities.
  /// </summary>
  IEntity = interface
    ['{DFEF00C0-5695-443E-91A7-E79E794ED794}']

    /// <summary>Sets the Id.</summary>
    procedure SetId(const aId: integer);

    /// <summary>Gets the Id.</summary>
    function GetId: integer;

    /// <summary>Returns true if the entity does not have an Id.</summary>
    function IsNew: boolean;

    /// <summary>Returns true if the entity does have an Id.</summary>
    function Exists: boolean;

    property Id: integer read GetId write SetId;
  end;

  /// <summary>
  ///  This is the base entity class all domain entities in Escape use.
  ///
  ///  The following conventions are enforced:
  ///   - Decorate transient properties with [Transient]
  ///   - The name of the database table matches the name of the entity (TCustomer => Customer)
  ///   - The name of the database columns match the names of the properties
  ///   - Every table has an autogenerated Id field
  /// </summary>
  TEntity = class(TTransient, IEntity)
  private
    fId: integer;
  public
    procedure SetId(const aId: integer);

    function GetId: integer;
    function IsNew: boolean;
    function Exists: boolean;
  end;

  /// <summary>
  ///  An interface for essential database functionality.
  /// </summary>
  IDatabaseService = interface
    ['{957F3224-AE99-4870-A2B9-11B11881FDE3}']

    function Connection: TFDConnection;
    function Query: TFDQuery;
  end;

  /// <summary>
  ///  Set directives to affect the queries, before the query is executed.
  ///  Directives are cleared after each request.
  /// </summary>
  TDirective = (
    /// <summary>Limit the number of records returned</summary>
    tdLimit,
    /// <summary>Order ascending.</summary>
    tdAscending,
    /// <summary>Order descending.</summary>
    tdDescending,
    /// <summary>Begin at record offset.</summary>
    tdOffset
  );

  /// <summary>
  ///  Base interface for the repositories.
  /// </summary>
  IRepository<TService: IEntity; T: TEntity, constructor> = interface
    ['{2B0A8B8E-2A59-43E7-8B3F-0A6B8A2A4A3C}']

//    function FirstBy(const aSpec: TSpecification<T>): TMaybe<T>;
    function GetAll(const aId: integer): TArray<TService>;
  end;

  /// <summary>
  ///  Base type for all repositories.
  /// </summary>
  TRepository<TService: IEntity; T: TEntity, constructor> = class(TDynamicObject, IRepository<TService, T>)
  private
    fDatabase: IDatabaseService;
  protected
    class var fName: string;
    class var fPropertyOrder: TList<string>;
    class var fProperties: TDictionary<string, TRttiProperty>;
    class var fDirectives: TDictionary<TDirective, string>;

    constructor Create(aDatabase: IDatabaseService);
  public
    function GetAll(const aId: integer): TArray<TService>;

    destructor Destroy; override;

    class constructor Create;
    class destructor Destroy;
  end;

implementation

uses
  System.Generics.Defaults;

{ TEntity }

{----------------------------------------------------------------------------------------------------------------------}
function TEntity.GetId: integer;
begin
  Result := fId;
end;

{----------------------------------------------------------------------------------------------------------------------}
procedure TEntity.SetId(const aId: integer);
begin
  fId := aId;
end;

{----------------------------------------------------------------------------------------------------------------------}
function TEntity.Exists: boolean;
begin
  Result := fId > 0;
end;

{----------------------------------------------------------------------------------------------------------------------}
function TEntity.IsNew: boolean;
begin
  Result := fId < 1;
end;


{ TRepository<TService, T> }

{----------------------------------------------------------------------------------------------------------------------}
constructor TRepository<TService, T>.Create(aDatabase: IDatabaseService);
begin
  inherited Create;

  fDatabase := aDatabase;
end;

{----------------------------------------------------------------------------------------------------------------------}
destructor TRepository<TService, T>.Destroy;
begin
  inherited;
end;

{----------------------------------------------------------------------------------------------------------------------}
class constructor TRepository<TService, T>.Create;
var
  lCtx: TRttiContext;
  lType: TRttiType;
  lProperty: TRttiProperty;
  lClass: TRttiInstanceType;
begin
  fDirectives := TDictionary<TDirective, string>.Create;
  fPropertyOrder := TList<string>.Create;

  lCtx   := TRttiContext.Create;

  try
    lType  := lCtx.GetType(T);
    lClass := TRttiInstanceType(lType);

    fName := lClass.Name;

    Ensure.IsTrue(fName.StartsWith('T', true), 'Entities follow T[Table] naming convention');

    fName := fName.Substring(1);

    fProperties := TDictionary<string, TRttiProperty>.Create(TIStringComparer.Ordinal);

    for lProperty in lType.GetProperties do
    begin
      if Assigned(lProperty.GetAttribute<TransientAttribute>()) then continue;

      fProperties.Add(lProperty.Name, lProperty);
      fPropertyOrder.Add(lProperty.Name);
    end;
  finally
    lCtx.Free;
  end;end;

{----------------------------------------------------------------------------------------------------------------------}
class destructor TRepository<TService, T>.Destroy;
begin
  FreeAndNil(fProperties);
  FreeAndNil(fPropertyOrder);
  FreeAndNil(fDirectives);
end;

{----------------------------------------------------------------------------------------------------------------------}
function TRepository<TService, T>.GetAll(const aId: integer): TArray<TService>;
begin
  //
end;

end.
